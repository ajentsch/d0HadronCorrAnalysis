//OLD CODE THAT I MAY NEED WHILE I DO UPDATES

/*double pt1            = 0.0;
    double pt2            = 1.0;                               // :::::::: May be better to store this stuff in a series of arrays.
    double pt3            = 2.0;
    double pt4            = 3.0;
    double pt5            = 5.0;
    double pt6            = 10.0;*/

/* double decayLength1   = .0145;
    double decayLength2   = .0181;
    double decayLength3   = .0212;
    double decayLength4   = .0247;
    double decayLength5   = .0259;*/
    
     /*double dcaDaughters1  = .0084;
    double dcaDaughters2  = .0066;
    double dcaDaughters3  = .0057;
    double dcaDaughters4  = .0050;
    double dcaDaughters5  = .0060;*/
    
     /*double dcaKaonPV1     = .0103;
    double dcaKaonPV2     = .0091;
    double dcaKaonPV3     = .0095;
    double dcaKaonPV4     = .0079;
    double dcaKaonPV5     = .0058;*/
    
    /*double dcaPionPV1     = .0110;
    double dcaPionPV2     = .0111;
    double dcaPionPV3     = .0086;
    double dcaPionPV4     = .0081;
    double dcaPionPV5     = .0062;*/
    
     /*double dcaV0toPV1     = .0061;
    double dcaV0toPV2     = .0049;
    double dcaV0toPV3     = .0038;
    double dcaV0toPV4     = .0038;
    double dcaV0toPV5     = .0040;*/
    
    
     /*double ptRange[6] = {0.0, 1.0, 2.0, 3.0, 5.0, 10.0};
    double decayLengthCuts[5] = {.0145, .0181, .0212, .0247, .0259};
    double daughterDCACuts[5] = {.0084, .0066, .0057, .0050, .0060};
    double dcaKaonPV[5] = {.0103, .0091, .0095, .0079, .0058};
    double dcaPionPV[5] = {.0110, .0111, .0086, .0081, .0062};
    double dcaV0toPV[5] = {.0061, .0049, .0038, .0038, .0040};*/
    
    
    /*invMassBin1      = new TH1D("unlikeSign_bin1", "unlikeSign_bin1", 50, 1.6, 2.1);
   invMassBin2      = new TH1D("unlikeSign_bin2", "unlikeSign_bin2", 50, 1.6, 2.1);
   invMassBin3      = new TH1D("unlikeSign_bin3", "unlikeSign_bin3", 50, 1.6, 2.1);
   invMassBin4      = new TH1D("unlikeSign_bin4", "unlikeSign_bin4", 50, 1.6, 2.1);
   invMassBin5      = new TH1D("unlikeSign_bin5", "unlikeSign_bin5", 50, 1.6, 2.1);

   likeSignBin1     = new TH1D("likeSign_bin1", "likeSign_bin1", 50, 1.6, 2.1);
   likeSignBin2     = new TH1D("likeSign_bin2", "likeSign_bin2", 50, 1.6, 2.1);
   likeSignBin3     = new TH1D("likeSign_bin3", "likeSign_bin3", 50, 1.6, 2.1);
   likeSignBin4     = new TH1D("likeSign_bin4", "likeSign_bin4", 50, 1.6, 2.1);
   likeSignBin5     = new TH1D("likeSign_bin5", "likeSign_bin5", 50, 1.6, 2.1);

   USminusLSBin1    = new TH1D("US-LS_bin1", "US-LS_bin1", 50, 1.6, 2.1);
   USminusLSBin2    = new TH1D("US-LS_bin2", "US-LS_bin2", 50, 1.6, 2.1);
   USminusLSBin3    = new TH1D("US-LS_bin3", "US-LS_bin3", 50, 1.6, 2.1);
   USminusLSBin4    = new TH1D("US-LS_bin4", "US-LS_bin4", 50, 1.6, 2.1);
   USminusLSBin5    = new TH1D("US-LS_bin5", "US-LS_bin5", 50, 1.6, 2.1);*/


   /*angCorrPhiBin1   = new TH1D("#Delta Phi bin 1", "#Delta#phi bin 1", 100, -TMath::PiOver2(), 3*TMath::PiOver2());
   angCorrEtaBin1   = new TH1D("#Delta#Eta bin 1", "#Delta#eta bin 1", 100, -2 , 2);
   angCorr2DBin1    = new TH2D("2D Ang Corr bin 1", "2D Ang Corr bin 1", 100, -2, 2, 100, -TMath::PiOver2(), 3*TMath::PiOver2());
   angCorrPhiBin2   = new TH1D("#Delta Phi bin 2", "#Delta#phi bin 2", 100, -TMath::PiOver2(), 3*TMath::PiOver2());
   angCorrEtaBin2   = new TH1D("#Delta#Eta bin 2", "#Delta#eta bin 2", 100, -2 , 2);
   angCorr2DBin2    = new TH2D("2D Ang Corr bin 2", "2D Ang Corr bin 2", 100, -2, 2, 100, -TMath::PiOver2(), 3*TMath::PiOver2());
   angCorrPhiBin3   = new TH1D("#Delta Phi bin 3", "#Delta#phi bin 3", 100, -TMath::PiOver2(), 3*TMath::PiOver2());
   angCorrEtaBin3   = new TH1D("#Delta#Eta bin 3", "#Delta#eta bin 3", 100, -2 , 2);
   angCorr2DBin3    = new TH2D("2D Ang Corr bin 3", "2D Ang Corr bin 3", 100, -2, 2, 100, -TMath::PiOver2(), 3*TMath::PiOver2());
   angCorrPhiBin4   = new TH1D("#Delta Phi bin 4", "#Delta#phi bin 4", 100, -TMath::PiOver2(), 3*TMath::PiOver2());
   angCorrEtaBin4   = new TH1D("#Delta#Eta bin 4", "#Delta#eta bin 4", 100, -2 , 2);
   angCorr2DBin4    = new TH2D("2D Ang Corr bin 4", "2D Ang Corr bin 4", 100, -2, 2, 100, -TMath::PiOver2(), 3*TMath::PiOver2());
   angCorrPhiBin5   = new TH1D("#Delta Phi bin 5", "#Delta#phi bin 5", 100, -TMath::PiOver2(), 3*TMath::PiOver2());
   angCorrEtaBin5   = new TH1D("#Delta#Eta bin 5", "#Delta#eta bin 5", 100, -2 , 2);
   angCorr2DBin5    = new TH2D("2D Ang Corr bin 5", "2D Ang Corr bin 5", 100, -2, 2, 100, -TMath::PiOver2(), 3*TMath::PiOver2());*/
   
   
   //pt bins for D0 pt -- NEED TO WRITE A FUNCTION TO DO THESE CUT CHECKS
                /*if(cutCheck(kp, pt1, pt2, decayLength1, 999999, dcaDaughters1, 0.0, 0.0, dcaKaonPV1, dcaPionPV1, dcaV0toPV1)){
                    angCorrPhiBin1->Fill(delPhi);
                    angCorrEtaBin1->Fill(delEta);
                    angCorr2DBin1->Fill(delEta, delPhi); 
                }
                    else if(cutCheck(kp, pt2, pt3, decayLength2, 999999, dcaDaughters2, 0.0, 0.0, dcaKaonPV2, dcaPionPV2, dcaV0toPV2)){
                        angCorrPhiBin2->Fill(delPhi);
                        angCorrEtaBin2->Fill(delEta);
                        angCorr2DBin2->Fill(delEta, delPhi);
                    }
                    else if(cutCheck(kp, pt3, pt4, decayLength3, 999999, dcaDaughters3, 0.0, 0.0, dcaKaonPV3, dcaPionPV3, dcaV0toPV3)){ 
                        angCorrPhiBin3->Fill(delPhi);
                        angCorrEtaBin3->Fill(delEta);
                        angCorr2DBin3->Fill(delEta, delPhi);
                    }
                    else if(cutCheck(kp, pt4, pt5, decayLength4, 999999, dcaDaughters4, 0.0, 0.0, dcaKaonPV4, dcaPionPV4, dcaV0toPV4)){
                        angCorrPhiBin4->Fill(delPhi);
                        angCorrEtaBin4->Fill(delEta);
                        angCorr2DBin4->Fill(delEta, delPhi);
                    }
                    else if(cutCheck(kp, pt5, pt6, decayLength5, 999999, dcaDaughters5, 0.0, 0.0, dcaKaonPV5, dcaPionPV5, dcaV0toPV5)){ 
                        angCorrPhiBin5->Fill(delPhi);
                        angCorrEtaBin5->Fill(delEta);
                        angCorr2DBin5->Fill(delEta, delPhi);
                    }  */

                    
                    /*angCorrPhiBin1->Write();
   angCorrEtaBin1->Write();
   angCorr2DBin1->Write();
   angCorrPhiBin2->Write();
   angCorrEtaBin2->Write();
   angCorr2DBin2->Write();
   angCorrPhiBin3->Write();
   angCorrEtaBin3->Write();
   angCorr2DBin3->Write();
   angCorrPhiBin4->Write();
   angCorrEtaBin4->Write();
   angCorr2DBin4->Write();
   angCorrPhiBin5->Write();
   angCorrEtaBin5->Write();
   angCorr2DBin5->Write();*/
   
    /*invMassBin1->Write();
   invMassBin2->Write();
   invMassBin3->Write();
   invMassBin4->Write();
   invMassBin5->Write();    
   likeSignBin1->Write();
   likeSignBin2->Write();
   likeSignBin3->Write();
   likeSignBin4->Write();
   likeSignBin5->Write();
   USminusLSBin1->Write();
   USminusLSBin2->Write();
   USminusLSBin3->Write();
   USminusLSBin4->Write();
   USminusLSBin5->Write();*/
   
   
   
   //if(kp->decayLength() > .0200 && kp->dcaDaughters() < .0055 && kp->kaonDca() > .008 && kp->pionDca() > .008 && 
                    //kp->kaonDca() > .008 && kp->pionDca() > .008 && kp->perpDcaToVtx() < .0065){ //D0 track cuts for pt-inclusive sibling dist.
                    
                     //if(kp->decayLength() > .0200 && kp->dcaDaughters() < .0055 && kp->kaonDca() > .008 && kp->pionDca() > .008 && 
                                                            //kp->kaonDca() > .008 && kp->pionDca() > .008 && kp->perpDcaToVtx() < .0065){ //D0 track cuts for pt-inclusive sibling dist.
                                                            
                                                            
  /*if     (cutCheck(kp, pt1, pt2, decayLength1, 999999.0, dcaDaughters1, kaonPtCut, pionPtCut, dcaKaonPV1, dcaPionPV1, dcaV0toPV1)) { likeSignBin1->Fill(kp->m()); }
          else if(cutCheck(kp, pt2, pt3, decayLength2, 999999.0, dcaDaughters2, kaonPtCut, pionPtCut, dcaKaonPV2, dcaPionPV2, dcaV0toPV2)) { likeSignBin2->Fill(kp->m()); }
          else if(cutCheck(kp, pt3, pt4, decayLength3, 999999.0, dcaDaughters3, kaonPtCut, pionPtCut, dcaKaonPV3, dcaPionPV3, dcaV0toPV3)) { likeSignBin3->Fill(kp->m()); }     //Fill likesign based on pt of D0
          else if(cutCheck(kp, pt4, pt5, decayLength4, 999999.0, dcaDaughters4, kaonPtCut, pionPtCut, dcaKaonPV4, dcaPionPV4, dcaV0toPV4)) { likeSignBin4->Fill(kp->m()); }
          else if(cutCheck(kp, pt5, pt6, decayLength5, 999999.0, dcaDaughters5, kaonPtCut, pionPtCut, dcaKaonPV5, dcaPionPV5, dcaV0toPV5)) { likeSignBin5->Fill(kp->m()); }*/
          
 /*if     (cutCheck(kp, pt1, pt2, decayLength1, 999999.0, dcaDaughters1, kaonPtCut, pionPtCut, dcaKaonPV1, dcaPionPV1, dcaV0toPV1)) { invMassBin1->Fill(kp->m()); } 
	      else if(cutCheck(kp, pt2, pt3, decayLength2, 999999.0, dcaDaughters2, kaonPtCut, pionPtCut, dcaKaonPV2, dcaPionPV2, dcaV0toPV2)) { invMassBin2->Fill(kp->m()); }
              else if(cutCheck(kp, pt3, pt4, decayLength3, 999999.0, dcaDaughters3, kaonPtCut, pionPtCut, dcaKaonPV3, dcaPionPV3, dcaV0toPV3)) { invMassBin3->Fill(kp->m()); }     //Fill invmass based on pt of D0
	      else if(cutCheck(kp, pt4, pt5, decayLength4, 999999.0, dcaDaughters4, kaonPtCut, pionPtCut, dcaKaonPV4, dcaPionPV4, dcaV0toPV4)) { invMassBin4->Fill(kp->m()); }
              else if(cutCheck(kp, pt5, pt6, decayLength5, 999999.0, dcaDaughters5, kaonPtCut, pionPtCut, dcaKaonPV5, dcaPionPV5, dcaV0toPV5)) { invMassBin5->Fill(kp->m()); }*/

              
              //pt = TMath::Sqrt((trk->pMom().x()*trk->pMom().x())+(trk->pMom().y()*trk->pMom().y()));
          //phi = trk->pMom().phi();  
          //eta = trk->pMom().pseudoRapidity();
          
          
          
          /*USminusLSBin1->Add(invMassBin1, likeSignBin1, 1, -1);
       USminusLSBin2->Add(invMassBin2, likeSignBin2, 1, -1);
       USminusLSBin3->Add(invMassBin3, likeSignBin3, 1, -1);
       USminusLSBin4->Add(invMassBin4, likeSignBin4, 1, -1);
       USminusLSBin5->Add(invMassBin5, likeSignBin5, 1, -1);*/
       
       
       //if(kp->decayLength() > .0200 && kp->dcaDaughters() < .0055 && kp->kaonDca() > .008 && kp->pionDca() > .008 && 
                                                            //kp->kaonDca() > .008 && kp->pionDca() > .008 && kp->perpDcaToVtx() < .0065){ //D0 track cuts for pt-inclusive sibling dist.
                
                
                //cutCheck(StKaonPion const* const kp, double ptMin, double ptMax, double decayLengthMin, double decayLengthMax, double dcaDaughters, 
      //         double kaonPtCut, double pionPtCut, double dcaKaontoPV, double dcaPiontoPV, double dcaV0toPV)

      //ptDist->Fill(kp->pt());
      
      
      
       /*if(DEBUG){
        
        for(int i = 0; i < eventBuffer[0][0]->getBufferSize(); i++){
            
            event = eventBuffer[0][0]->getEvent(i);
            nTracks = event->getNoTracks();
            mixedEventTest->Fill(nTracks);
            
            for(int j = 0; j < nTracks; j++){
            
               mixedTrack = event->getTrack(j);
               mixedHadronPtDist->Fill(mixedTrack.gMom().perp());
            }
            
            for (int idx = 0; idx < event->getKaonPionListSize(); idx++){
   
                kaonPionTrack = event->getKaonPionAt(idx);
                mixedEventKPInvMass->Fill(kaonPionTrack.mass());
            
            }    
      }
   }   */
        
   //Final histogram calculations done here     
      
   double numSib = angCorr2DAll->Integral(1,25,1,25);
   double numMix = mixedEventAngCorr2DAll->Integral(1,25,1,25);

   angCorr2DAll->Scale(numMix/numSib);

   fullCorr->Add(angCorr2DAll, mixedEventAngCorr2DAll, 1, -1);   
   
   fullCorr->Divide(mixedEventAngCorr2DAll);
   
   
   for(int i = 0; i < 9; i++){
        for( int j = 0; j < 11; j++){
        
            numSib = scaledSibCorrBin[i][j]->Integral(1,25,1,25); 
            numMix = mixCorrBin[i][j]->Integral(1,25,1,25);
           
            scaledSibCorrBin[i][j]->Scale(numMix/numSib);  
             
            fullCorrBin[i][j]->Add(scaledSibCorrBin[i][j], mixCorrBin[i][j], 1, -1);   
   
            fullCorrBin[i][j]->Divide(mixCorrBin[i][j]); 
            
               
            delete eventBuffer[i][j]; 
        
        }
   }   
   
   
    //cout <<  "nTracks1: " << nTracks1 << "   nTracks2: " << nTracks2 << "     kaonPionListSize:  " << event1->getKaonPionListSize() <<  endl;
                //cout << "Kaon Index: " << kaonPionTrack1.kaonIdx() << "    Pion index: " << kaonPionTrack1.pionIdx() << endl;
                
                
                //if(kaon->gPt() > 1.2 && pion->gPt() > 1.2 && kp->decayLength() > .0200 && kp->dcaDaughters() < .0055 &&  kp->kaonDca() > .008 && 
                                  //kp->pionDca() > .008 && kp->perpDcaToVtx() < .0065){ 
                                  
                                  
                                  
                                  
                                  
                                  
ORIGINAL EVENT MIXER HERE

if(eventBuffer[VzBin][centralityBin]->getBufferMaxSize() == eventBuffer[VzBin][centralityBin]->getBufferSize()){
    
        if(DEBUG){cout << "Mixing events in Vz/Centrality Bin " << VzBin<< "/" << centralityBin << endl;}
    
        StMixerEvent* event1;
        StMixerEvent* event2;
        StMixerEvent* event3;
        
        StMixerTrack kaonPionTrack1;
        StMixerTrack mixedTrack2;
        StMixerTrack mixedTrack3;
        
        int nTracks1 = 0;
        int nTracks2 = 0;
        int nTracks3 = 0;
        
        
        for(int i = 0; i < eventBuffer[VzBin][centralityBin]->getBufferSize(); i++){
            
            
            if( i < eventBuffer[VzBin][centralityBin]->getBufferSize()-2)  //for 5 events, this means i is 0, 1, 2
            {
                event1 = eventBuffer[VzBin][centralityBin]->getEvent(i);
                event2 = eventBuffer[VzBin][centralityBin]->getEvent(i+1);
                event3 = eventBuffer[VzBin][centralityBin]->getEvent(i+2);
                nTracks1 = event1->getNoTracks();
                nTracks2 = event2->getNoTracks();
                nTracks3 = event3->getNoTracks();
                
                if(DEBUG_MIX_BUFFER){cout << "mixing events in buffer " << i << " with " << i+1 << "  and " << i+2 << endl;}
            }    
            
            else if(i == eventBuffer[VzBin][centralityBin]->getBufferSize()-2)  //for 5 events, this means i is 3, 4, 0
            {
                event1 = eventBuffer[VzBin][centralityBin]->getEvent(i);
                event2 = eventBuffer[VzBin][centralityBin]->getEvent(i+1);
                event3 = eventBuffer[VzBin][centralityBin]->getEvent(0);
                nTracks1 = event1->getNoTracks();
                nTracks2 = event2->getNoTracks();
                nTracks3 = event3->getNoTracks();
                
                if(DEBUG_MIX_BUFFER){cout << "mixing events in buffer " << i << " with " << i+1 << "  and 0 " <<  endl;}
            }    
                
            else if(i == eventBuffer[VzBin][centralityBin]->getBufferSize()-1)  //for 5 events, this means i is 4, 0, 1
            {
                event1 = eventBuffer[VzBin][centralityBin]->getEvent(i);
                event2 = eventBuffer[VzBin][centralityBin]->getEvent(0);
                event3 = eventBuffer[VzBin][centralityBin]->getEvent(1);
                nTracks1 = event1->getNoTracks();
                nTracks2 = event2->getNoTracks();
                nTracks3 = event3->getNoTracks();
                
                if(DEBUG_MIX_BUFFER){cout << "mixing events in buffer " << i << " with 0 and 1 "<<  endl;}
            }    
            
            
           for (int idx = 0; idx < event1->getKaonPionListSize(); idx++){
                
                kaonPionTrack1 = event1->getKaonPionAt(idx);
                StMixerTrack mixerKaon = event1->getTrack(kaonPionTrack1.kaonIdx());
                StMixerTrack mixerPion = event1->getTrack(kaonPionTrack1.pionIdx());
                
                
                if(kaonPionTrack1.mass() > D0InvMassLow && kaonPionTrack1.mass() < D0InvMassHigh){//begin D0 conditional  && mixerKaon.charge()*mixerPion.charge() < 0
                 
                    for(int j = 0; j < nTracks2; j++){//begin loop over event 2 tracks
                        
                        if(j == kaonPionTrack1.kaonIdx() || j == kaonPionTrack1.pionIdx()) { continue; }                                
                        
                        mixedTrack2 = event2->getTrack(j);                                                            
           	            trackMom = mixedTrack2.gMom();
               
                        
               
                        pt = TMath::Sqrt((trackMom.x()*trackMom.x())+(trackMom.y()*trackMom.y())); 
                        phi = TMath::ATan2(trackMom.y(),trackMom.x());  
                        eta = trackMom.pseudoRapidity();
                 
                        delPhi = kaonPionTrack1.gMom().phi()-phi;
                        if(delPhi < -TMath::PiOver2()){ delPhi = delPhi + 2*TMath::Pi(); }
                            else if(delPhi >= 3*TMath::PiOver2()){ delPhi = delPhi - 2*TMath::Pi(); }
                
                        delEta =kaonPionTrack1.gMom().pseudoRapidity()-eta;
                
                        if(mixerKaon.charge()*mixerPion.charge() < 0){
                
                            //USmixedEventAngCorr2DAll->Fill(delEta, delPhi);
                            mixCorrBinUS[VzBin][centralityBin]->Fill(delEta, delPhi);
            
                        }
                        
                        if(mixerKaon.charge()*mixerPion.charge() > 0){

                            //LSmixedEventAngCorr2DAll->Fill(delEta, delPhi);
                            mixCorrBinLS[VzBin][centralityBin]->Fill(delEta, delPhi);
                        
                        }
                    
                    }//end loop over event 2 tracks
                    
                    
                    for(int k = 0; k < nTracks3; k++){//begin loop over event 3
                        
                        if(k == kaonPionTrack1.kaonIdx() || k == kaonPionTrack1.pionIdx()) { continue; }                                
                        
                        mixedTrack3 = event3->getTrack(k);                                                            
           	            trackMom = mixedTrack3.gMom();
                        
                        pt = TMath::Sqrt((trackMom.x()*trackMom.x())+(trackMom.y()*trackMom.y())); 
                        phi = TMath::ATan2(trackMom.y(),trackMom.x());  
                        eta = trackMom.pseudoRapidity();
                 
                        delPhi = kaonPionTrack1.gMom().phi()-phi;
                        if(delPhi < -TMath::PiOver2()){ delPhi = delPhi + 2*TMath::Pi(); }
                            else if(delPhi >= 3*TMath::PiOver2()){ delPhi = delPhi - 2*TMath::Pi(); }
                
                        delEta = kaonPionTrack1.gMom().pseudoRapidity()-eta;
                
                        if(mixerKaon.charge()*mixerPion.charge() < 0){
                
                            //USmixedEventAngCorr2DAll->Fill(delEta, delPhi);
                            mixCorrBinUS[VzBin][centralityBin]->Fill(delEta, delPhi);
                        
                        }
                        
                        if(mixerKaon.charge()*mixerPion.charge() > 0){

                            //LSmixedEventAngCorr2DAll->Fill(delEta, delPhi);
                            mixCorrBinLS[VzBin][centralityBin]->Fill(delEta, delPhi);
                        
                        }
                        
                        
                            
                    }//end loop over event 3 tracks
                
                }//end conditional for d0
                
            }//end loop over event 1 kaon-pion list
       
       }//end event buffer loop   


 /*if(DEBUG_MIX_BUFFER){
                    buffIdx  = eventBufferUS[VzBin][centralityBin]->getBufferIndex()-1;
                    cout << "eta from buffer: " << eventBufferUS[VzBin][centralityBin]->getEvent(buffIdx)->getKaonPionAt(i).gMom().pseudoRapidity() << endl;
                    cout << "Kaon buffer index: " << eventBufferUS[VzBin][centralityBin]->getEvent(buffIdx)->getKaonPionAt(i).kaonIdx() << "    Pion buffer index: " << eventBufferUS[VzBin][centralityBin]->getEvent(buffIdx)->getKaonPionAt(i).pionIdx() << endl;
                    cout << "______________________________________________________" << endl;
                } */  






--------------------------ORIGINAL MIXING CODE----------------------------------------

if(eventBufferUS[VzBin][centralityBin]->getBufferMaxSize() == eventBufferUS[VzBin][centralityBin]->getBufferSize()){ //begin buffer-full US mixing conditional
    
        if(DEBUG){cout << "Mixing US events in Vz/Centrality Bin " << VzBin<< "/" << centralityBin << endl;}
    
        StMixerEvent* event1;
        StMixerEvent* event2;
        StMixerEvent* event3;
        
        StMixerTrack kaonPionTrack1;
        StMixerTrack mixedTrack2;
        StMixerTrack mixedTrack3;
        
        int nTracks1 = 0;
        int nTracks2 = 0;
        int nTracks3 = 0;
        
        
        for(int i = 0; i < eventBufferUS[VzBin][centralityBin]->getBufferSize(); i++){ //begin even buffer loop
            
            
            if( i < eventBufferUS[VzBin][centralityBin]->getBufferSize()-2)  //for 5 events, this means i is 0, 1, 2
            {
                event1 = eventBufferUS[VzBin][centralityBin]->getEvent(i);
                event2 = eventBufferUS[VzBin][centralityBin]->getEvent(i+1);
                event3 = eventBufferUS[VzBin][centralityBin]->getEvent(i+2);
                nTracks1 = event1->getNoTracks();
                nTracks2 = event2->getNoTracks();
                nTracks3 = event3->getNoTracks();
                
                if(DEBUG_MIX_BUFFER){cout << "mixing events in buffer " << i << " with " << i+1 << "  and " << i+2 << endl;}
            }    
            
            else if(i == eventBufferUS[VzBin][centralityBin]->getBufferSize()-2)  //for 5 events, this means i is 3, 4, 0
            {
                event1 = eventBufferUS[VzBin][centralityBin]->getEvent(i);
                event2 = eventBufferUS[VzBin][centralityBin]->getEvent(i+1);
                event3 = eventBufferUS[VzBin][centralityBin]->getEvent(0);
                nTracks1 = event1->getNoTracks();
                nTracks2 = event2->getNoTracks();
                nTracks3 = event3->getNoTracks();
                
                if(DEBUG_MIX_BUFFER){cout << "mixing events in buffer " << i << " with " << i+1 << "  and 0 " <<  endl;}
            }    
                
            else if(i == eventBufferUS[VzBin][centralityBin]->getBufferSize()-1)  //for 5 events, this means i is 4, 0, 1
            {
                event1 = eventBufferUS[VzBin][centralityBin]->getEvent(i);
                event2 = eventBufferUS[VzBin][centralityBin]->getEvent(0);
                event3 = eventBufferUS[VzBin][centralityBin]->getEvent(1);
                nTracks1 = event1->getNoTracks();
                nTracks2 = event2->getNoTracks();
                nTracks3 = event3->getNoTracks();
                
                if(DEBUG_MIX_BUFFER){cout << "mixing US events in buffer " << i << " with 0 and 1 "<<  endl;}
            }    
            
            
           for (int idx = 0; idx < event1->getKaonPionListSize(); idx++){//begin loop over event 1 kaon-pion list
                
                kaonPionTrack1 = event1->getKaonPionAt(idx);
                StMixerTrack mixerKaon = event1->getTrack(kaonPionTrack1.kaonIdx());
                StMixerTrack mixerPion = event1->getTrack(kaonPionTrack1.pionIdx());
                
                
                if(kaonPionTrack1.mass() > D0InvMassLow && kaonPionTrack1.mass() < D0InvMassHigh){//begin D0 conditional  && mixerKaon.charge()*mixerPion.charge() < 0
                 
                    for(int j = 0; j < nTracks2; j++){//begin loop over event 2 tracks
                        
                        if(j == kaonPionTrack1.kaonIdx() || j == kaonPionTrack1.pionIdx()) { continue; }                                
                        
                        mixedTrack2 = event2->getTrack(j);                                                            
           	            trackMom = mixedTrack2.gMom();
               
                        
               
                        pt = TMath::Sqrt((trackMom.x()*trackMom.x())+(trackMom.y()*trackMom.y())); 
                        phi = TMath::ATan2(trackMom.y(),trackMom.x());  
                        eta = trackMom.pseudoRapidity();
                 
                        delPhi = kaonPionTrack1.gMom().phi()-phi;
                        if(delPhi < -TMath::PiOver2()){ delPhi = delPhi + 2*TMath::Pi(); }
                            else if(delPhi >= 3*TMath::PiOver2()){ delPhi = delPhi - 2*TMath::Pi(); }
                
                        delEta =kaonPionTrack1.gMom().pseudoRapidity()-eta;
                
                        if(mixerKaon.charge()*mixerPion.charge() < 0){
                
                            //USmixedEventAngCorr2DAll->Fill(delEta, delPhi);
                            mixCorrBinUS[VzBin][centralityBin]->Fill(delEta, delPhi);
            
                        }
                        
                        /*if(mixerKaon.charge()*mixerPion.charge() > 0){

                            //LSmixedEventAngCorr2DAll->Fill(delEta, delPhi);
                            mixCorrBinLS[VzBin][centralityBin]->Fill(delEta, delPhi);
                        
                        }*/
                    
                    }//end loop over event 2 tracks
                    
                    
                    for(int k = 0; k < nTracks3; k++){//begin loop over event 3
                        
                        if(k == kaonPionTrack1.kaonIdx() || k == kaonPionTrack1.pionIdx()) { continue; }                                
                        
                        mixedTrack3 = event3->getTrack(k);                                                            
           	            trackMom = mixedTrack3.gMom();
                        
                        pt = TMath::Sqrt((trackMom.x()*trackMom.x())+(trackMom.y()*trackMom.y())); 
                        phi = TMath::ATan2(trackMom.y(),trackMom.x());  
                        eta = trackMom.pseudoRapidity();
                 
                        delPhi = kaonPionTrack1.gMom().phi()-phi;
                        if(delPhi < -TMath::PiOver2()){ delPhi = delPhi + 2*TMath::Pi(); }
                            else if(delPhi >= 3*TMath::PiOver2()){ delPhi = delPhi - 2*TMath::Pi(); }
                
                        delEta = kaonPionTrack1.gMom().pseudoRapidity()-eta;
                
                        if(mixerKaon.charge()*mixerPion.charge() < 0){
                
                            //USmixedEventAngCorr2DAll->Fill(delEta, delPhi);
                            mixCorrBinUS[VzBin][centralityBin]->Fill(delEta, delPhi);
                        
                        }
                        
                        /*if(mixerKaon.charge()*mixerPion.charge() > 0){

                            //LSmixedEventAngCorr2DAll->Fill(delEta, delPhi);
                            mixCorrBinLS[VzBin][centralityBin]->Fill(delEta, delPhi);
                        
                        }*/
                        
                        
                            
                    }//end loop over event 3 tracks
                
                }//end conditional for d0
                
            }//end loop over event 1 kaon-pion list
       
       }//end event buffer loop   
/********************************************************************END EVENT MIXER BLOCK*****************************************/    
      
      eventBufferUS[VzBin][centralityBin]->clearBuffer();
      eventBufferUS[VzBin][centralityBin]->setBufferCounter(0);
      
      if(DEBUG) { 
        
        cout << endl << endl;
        cout << "US buffer for Vz/centrality bin "<< VzBin << "/"<< centralityBin<< " cleared" << endl;
        cout << endl;
  
      }     
      
      
      

     }//end buffer-full US mixing conditional
     
     
     
     
     if(eventBufferLS[VzBin][centralityBin]->getBufferMaxSize() == eventBufferLS[VzBin][centralityBin]->getBufferSize()){ //begin buffer-full LS mixing conditional
    
        if(DEBUG){cout << "Mixing LS events in Vz/Centrality Bin " << VzBin<< "/" << centralityBin << endl;}
    
        StMixerEvent* event1;
        StMixerEvent* event2;
        StMixerEvent* event3;
        
        StMixerTrack kaonPionTrack1;
        StMixerTrack mixedTrack2;
        StMixerTrack mixedTrack3;
        
        int nTracks1 = 0;
        int nTracks2 = 0;
        int nTracks3 = 0;
        
        
        for(int i = 0; i < eventBufferLS[VzBin][centralityBin]->getBufferSize(); i++){ //begin event buffer loop
            
            
            if( i < eventBufferLS[VzBin][centralityBin]->getBufferSize()-2)  //for 5 events, this means i is 0, 1, 2
            {
                event1 = eventBufferLS[VzBin][centralityBin]->getEvent(i);
                event2 = eventBufferLS[VzBin][centralityBin]->getEvent(i+1);
                event3 = eventBufferLS[VzBin][centralityBin]->getEvent(i+2);
                nTracks1 = event1->getNoTracks();
                nTracks2 = event2->getNoTracks();
                nTracks3 = event3->getNoTracks();
                
                if(DEBUG_MIX_BUFFER){cout << "mixing LS events in buffer " << i << " with " << i+1 << "  and " << i+2 << endl;}
            }    
            
            else if(i == eventBufferLS[VzBin][centralityBin]->getBufferSize()-2)  //for 5 events, this means i is 3, 4, 0
            {
                event1 = eventBufferLS[VzBin][centralityBin]->getEvent(i);
                event2 = eventBufferLS[VzBin][centralityBin]->getEvent(i+1);
                event3 = eventBufferLS[VzBin][centralityBin]->getEvent(0);
                nTracks1 = event1->getNoTracks();
                nTracks2 = event2->getNoTracks();
                nTracks3 = event3->getNoTracks();
                
                if(DEBUG_MIX_BUFFER){cout << "mixing LS events in buffer " << i << " with " << i+1 << "  and 0 " <<  endl;}
            }    
                
            else if(i == eventBufferLS[VzBin][centralityBin]->getBufferSize()-1)  //for 5 events, this means i is 4, 0, 1
            {
                event1 = eventBufferLS[VzBin][centralityBin]->getEvent(i);
                event2 = eventBufferLS[VzBin][centralityBin]->getEvent(0);
                event3 = eventBufferLS[VzBin][centralityBin]->getEvent(1);
                nTracks1 = event1->getNoTracks();
                nTracks2 = event2->getNoTracks();
                nTracks3 = event3->getNoTracks();
                
                if(DEBUG_MIX_BUFFER){cout << "mixing LS events in buffer " << i << " with 0 and 1 "<<  endl;}
            }    
            
            
           for (int idx = 0; idx < event1->getKaonPionListSize(); idx++){//begin loop over event 1 kaon-pion list
                
                kaonPionTrack1 = event1->getKaonPionAt(idx);
                StMixerTrack mixerKaon = event1->getTrack(kaonPionTrack1.kaonIdx());
                StMixerTrack mixerPion = event1->getTrack(kaonPionTrack1.pionIdx());
                
                
                if(kaonPionTrack1.mass() > D0InvMassLow && kaonPionTrack1.mass() < D0InvMassHigh){//begin D0 conditional  && mixerKaon.charge()*mixerPion.charge() < 0
                 
                    for(int j = 0; j < nTracks2; j++){//begin loop over event 2 tracks
                        
                        if(j == kaonPionTrack1.kaonIdx() || j == kaonPionTrack1.pionIdx()) { continue; }                                
                        
                        mixedTrack2 = event2->getTrack(j);                                                            
           	            trackMom = mixedTrack2.gMom();
               
                        
               
                        pt = TMath::Sqrt((trackMom.x()*trackMom.x())+(trackMom.y()*trackMom.y())); 
                        phi = TMath::ATan2(trackMom.y(),trackMom.x());  
                        eta = trackMom.pseudoRapidity();
                 
                        delPhi = kaonPionTrack1.gMom().phi()-phi;
                        if(delPhi < -TMath::PiOver2()){ delPhi = delPhi + 2*TMath::Pi(); }
                            else if(delPhi >= 3*TMath::PiOver2()){ delPhi = delPhi - 2*TMath::Pi(); }
                
                        delEta =kaonPionTrack1.gMom().pseudoRapidity()-eta;
                
                        /*if(mixerKaon.charge()*mixerPion.charge() < 0){
                
                            
                            mixCorrBinUS[VzBin][centralityBin]->Fill(delEta, delPhi);
            
                        }*/
                        
                        if(mixerKaon.charge()*mixerPion.charge() > 0){

                            
                            mixCorrBinLS[VzBin][centralityBin]->Fill(delEta, delPhi);
                        
                        }
                    
                    }//end loop over event 2 tracks
                    
                    
                    for(int k = 0; k < nTracks3; k++){//begin loop over event 3
                        
                        if(k == kaonPionTrack1.kaonIdx() || k == kaonPionTrack1.pionIdx()) { continue; }                                
                        
                        mixedTrack3 = event3->getTrack(k);                                                            
           	            trackMom = mixedTrack3.gMom();
                        
                        pt = TMath::Sqrt((trackMom.x()*trackMom.x())+(trackMom.y()*trackMom.y())); 
                        phi = TMath::ATan2(trackMom.y(),trackMom.x());  
                        eta = trackMom.pseudoRapidity();
                 
                        delPhi = kaonPionTrack1.gMom().phi()-phi;
                        if(delPhi < -TMath::PiOver2()){ delPhi = delPhi + 2*TMath::Pi(); }
                            else if(delPhi >= 3*TMath::PiOver2()){ delPhi = delPhi - 2*TMath::Pi(); }
                
                        delEta = kaonPionTrack1.gMom().pseudoRapidity()-eta;
                
                        /*if(mixerKaon.charge()*mixerPion.charge() < 0){
                
                            
                            mixCorrBinUS[VzBin][centralityBin]->Fill(delEta, delPhi);
                        
                        }*/
                        
                        if(mixerKaon.charge()*mixerPion.charge() > 0){

                            
                            mixCorrBinLS[VzBin][centralityBin]->Fill(delEta, delPhi);
                        
                        }
                        
                        
                            
                    }//end loop over event 3 tracks
                
                }//end conditional for d0
                
            }//end loop over event 1 kaon-pion list
       
       }//end event buffer loop   
/********************************************************************END EVENT MIXER BLOCK*****************************************/    
      
      eventBufferLS[VzBin][centralityBin]->clearBuffer();
      eventBufferLS[VzBin][centralityBin]->setBufferCounter(0);
      
      if(DEBUG) { 
        
        cout << endl << endl;
        cout << "buffer for LS Vz/centrality bin "<< VzBin << "/"<< centralityBin<< " cleared" << endl;
        cout << endl;
  
      }     
      
      
      

     }//end buffer-full LS mixing conditional





   
    /*ptRange[6] = {0.0, 1.0, 2.0, 3.0, 5.0, 10.0};
    decayLengthCuts[5] = {.0145, .0181, .0212, .0247, .0259};
    daughterDCACuts[5] = {.0084, .0066, .0057, .0050, .0060};
    dcaKaonPV[5] = {.0103, .0091, .0095, .0079, .0058};
    dcaPionPV[5] = {.0110, .0111, .0086, .0081, .0062};
    dcaV0toPV[5] = {.0061, .0049, .0038, .0038, .0040};*/     
    
    
    //pt   = TMath::Sqrt((trackMom.x()*trackMom.x())+(trackMom.y()*trackMom.y()));
                //phi  = TMath::ATan2(trackMom.y(),trackMom.x());  
                //eta  = trackMom.pseudoRapidity();
            
                //if(mHFCuts->isGoodTrack(trk) && (fabs(trk->nSigmaKaon()) < 2.0)){ PIDflag = 1; }
                  //  else if(mHFCuts->isGoodTrack(trk) && (fabs(trk->nSigmaPion()) < 3.0)) { PIDflag = 2; }
                    //else PIDflag = 0;
                    
                    
                    
                    
 //int i = 0;
        //int buffIdx = 0;
        
        /*for (int idx = 0; idx < aKaonPion->GetEntries(); ++idx){//begin loop to add kaonPions to event
   
            StKaonPion const* kp = (StKaonPion*)aKaonPion->At(idx);
            StPicoTrack const* kaon = picoDst->track(kp->kaonIdx());
            StPicoTrack const* pion = picoDst->track(kp->pionIdx());
   
            if(!isGoodPair(kp)) continue; 
            if(!cutCheck(kp, d0PtLow,  d0PtHigh,  d0DecayLengthMin,  d0DecayLengthMax,  daughterDCA,
                     d0DaughterPionPtMin, d0DaughterKaonPtMin, kaonDCA,  pionDCA,  d0DCAtoPV)) { continue; }
            
            if(kp->m() > D0InvMassLow && kp->m() < D0InvMassHigh){ 
                
                kaonPionMom.set(kp->lorentzVector().px(),kp->lorentzVector().py(),kp->lorentzVector().pz());
                pairCharge = kaon->charge()*pion->charge(); //THIS IS NOT THE ACTUAL CHARGE -- SIMPLY THE US/LS VALUE
                if(pairCharge < 0 ){
                    
                    eventBufferUS[VzBin][centralityBin]->addKaonPionToEvent(eventBufferUS[VzBin][centralityBin]->getBufferIndex()-1, kaonPionMom, kp->m(), kp->kaonIdx(), kp->pionIdx(), pairCharge);
                }
                
                else if(pairCharge > 0){
                
                    eventBufferLS[VzBin][centralityBin]->addKaonPionToEvent(eventBufferLS[VzBin][centralityBin]->getBufferIndex()-1, kaonPionMom, kp->m(), kp->kaonIdx(), kp->pionIdx(), pairCharge);
                
                }
                
                if(DEBUG_MIX_BUFFER){ 
                    
                    cout << "Actual eta from picoDst: " << kp->eta() << endl;
                    
                    cout << "KaonPion charge from event info(LS or US): " << kaon->charge()*pion->charge() << endl;
                    cout << "KaonPion mass: " << kp->m() << endl;
                    cout << "_______________________________________________" << endl;
                    cout << endl;
                    
                    
                }    
                
                i++;               
            }
   
        }//end loop to add kaonPions to event*/
        
        
        //if(!isGoodPair(kp)) continue;             
        //if(!cutCheck(kp, d0PtLow,  d0PtHigh,  d0DecayLengthMin,  d0DecayLengthMax,  daughterDCA,
        //d0DaughterPionPtMin, d0DaughterKaonPtMin, kaonDCA,  pionDCA,  d0DCAtoPV)) { continue; }
        //if(pion->charge()*kaon->charge() < 0 && !USEventStoredInBuffer){ //If an US pair exists and the event was not previously stored, store it
        
        
        
        
 
     ////////////////Fill QA Histograms from pair trees //////////////////////
        //kaonDCAfromD0->Fill(kp->kaonDca());
        //pionDCAfromD0->Fill(kp->pionDca());
        //decayLengthQA->Fill(kp->decayLength());
        //pointingAngleQA->Fill(kp->pointingAngle());
        //daughterDCAQA->Fill(kp->dcaDaughters());
    /////////////////////////////////////////////////////////////////////////
    
    
     /***********************************************BEGIN LIKE SIGN EVENT MIXER BLOCK*******************************************/  
      
    /*if(eventBufferLS[VzBin][centralityBin]->getBufferMaxSize() == eventBufferLS[VzBin][centralityBin]->getBufferSize()){ //begin buffer-full US mixing conditional
    
        if(DEBUG){cout << "Mixing LS events in Vz/Centrality Bin " << VzBin<< "/" << centralityBin << endl << endl;}
    
        StMixerEvent* event1;
        StMixerEvent* event2;
        
        StMixerTrack kaonPionTrack1;
        StMixerTrack mixedTrack2;
        
        //int nTracks1 = 0;
        int nTracks2 = 0;
        
        event1 = eventBufferLS[VzBin][centralityBin]->getEvent(0); //The first event in the buffer will be the trigger D0 event
        
        for(int i = 1; i < eventBufferLS[VzBin][centralityBin]->getBufferSize(); i++){ //begin associated event buffer loop
            
            if(DEBUG) { 
        
                //cout << endl << endl;
                cout << "Mixing LS Event 0 with LS Event " << i << "." << endl;
                cout << endl;
            
            }     
            
            event2 = eventBufferLS[VzBin][centralityBin]->getEvent(i); //This is the event for the associated hadrons
            nTracks2 = event2->getNoTracks();
            
            for (int idx = 0; idx < event1->getKaonPionListSize(); idx++){//begin loop over event 1 kaon-pion list
                
                kaonPionTrack1 = event1->getKaonPionAt(idx);
                StMixerTrack mixerKaon = event1->getTrack(kaonPionTrack1.kaonIdx());
                StMixerTrack mixerPion = event1->getTrack(kaonPionTrack1.pionIdx());
                
                if(mixerKaon.charge()*mixerPion.charge() < 0){ continue; }
                
                if(kaonPionTrack1.mass() > D0InvMassLow && kaonPionTrack1.mass() < D0InvMassHigh){//begin D0 trigger conditional 
                 
                    for(int j = 0; j < nTracks2; j++){//begin loop over event 2 tracks
                        
                        //if(j == kaonPionTrack1.kaonIdx() || j == kaonPionTrack1.pionIdx()) { continue; }                                
                        
                        mixedTrack2 = event2->getTrack(j);                                                            
           	            trackMom = mixedTrack2.gMom();
               
                        pt = TMath::Sqrt((trackMom.x()*trackMom.x())+(trackMom.y()*trackMom.y())); 
                        phi = TMath::ATan2(trackMom.y(),trackMom.x());  
                        eta = trackMom.pseudoRapidity();
                 
                        delPhi = kaonPionTrack1.gMom().phi()-phi;
                        if(delPhi < -TMath::PiOver2()){ delPhi = delPhi + 2*TMath::Pi(); }
                            else if(delPhi >= 3*TMath::PiOver2()){ delPhi = delPhi - 2*TMath::Pi(); }
                
                        delEta = kaonPionTrack1.gMom().pseudoRapidity()-eta;
                
                        mixCorrBinLS[VzBin][centralityBin]->Fill(delEta, delPhi); //delEta & delPhi stored in US mixed correlation histogram
            
                    }// end loop over event 2 tracks
                }// end D0 trigger conditional
            }// end loop over event 1 kaon-pion list
        }// end associated event buffer loop
        
        eventBufferLS[VzBin][centralityBin]->removeFirstEvent();
      
        if(DEBUG) { 
        
            cout << endl << endl;
            cout << "First Event in LS buffer for Vz/centrality bin "<< VzBin << "/"<< centralityBin<< " cleared" << endl;
            cout << endl;
            cout << "buffer size after removal of first event: " << eventBufferLS[VzBin][centralityBin]->getBufferSize() << endl;
       }     
        
    }// end buffer-full LS mixing conditional    
    */
    /***********************************************END LIKE SIGN EVENT MIXER BLOCK*******************************************/
    
    
    
    
    
    
    //LS part
        
                /*formatCorrHist(sibMinusScaledMixLS[i]); //formatting
        
                sibMinusScaledMixLS[i]->Draw("SURF1");
                str1 = path + outputFolders[3] + sibMinusScaledMixLSLabel1 + binLabelCent[i] + fileType;
                c->SaveAs(str1);
        
                str1 = phiProj + sibMinusScaledMixLSLabel1 + binLabelCent[i];         //sib - scaled mix phi projection LS 
                sibMinusScaledMixLSPhiProj[i] = new TH1D(str1, str1, NUM_PHI_BINS, -TMath::PiOver2(), 3*TMath::PiOver2());  
                sibMinusScaledMixLSPhiProj[i] = (TH1D*)sibMinusScaledMixLS[i]->ProjectionY();  
                str1 = path + outputFolders[3] + phiProj + sibMinusScaledMixLSLabel1 + binLabelCent[i] + fileType;        
                sibMinusScaledMixLSPhiProj[i]->Draw();
                c->SaveAs(str1);*/

                /*for(int i = 8; i < 11; i++){ //begin delRho_over_rho_US minus delRho_over_rho_LS
   
        str1 = delRhoOverRhoRefUSMinusLSLabel1 + binLabelCent[i];
        fullySubtractedCorrCent[i] = new TH2D(str1, str1, NUM_ETA_BINS, -2, 2, NUM_PHI_BINS, -TMath::PiOver2(), 3*TMath::PiOver2());
        
        delRhoOverRhoRefLSBin[i]->Scale(LSScaleFactor);                 //very crude LS scaling
        
        fullySubtractedCorrCent[i]->Add(delRhoOverRhoRefUSBin[i], delRhoOverRhoRefLSBin[i], 1, -1);
        
        fullySubtractedCorrCent[i]->GetXaxis()->SetTitle("#Delta#eta");
        fullySubtractedCorrCent[i]->GetYaxis()->SetTitle("#Delta#phi");
        fullySubtractedCorrCent[i]->GetXaxis()->SetTitleOffset(1.3);
        fullySubtractedCorrCent[i]->GetYaxis()->SetTitleOffset(1.3); 
        fullySubtractedCorrCent[i]->GetXaxis()->SetTitle("#Delta#eta");
        fullySubtractedCorrCent[i]->GetYaxis()->SetTitle("#Delta#phi");
        fullySubtractedCorrCent[i]->GetXaxis()->SetTitleOffset(1.3);
        fullySubtractedCorrCent[i]->GetYaxis()->SetTitleOffset(1.3); 
        //fullySubtractedCorrCent[i]->GetXaxis()->SetRangeUser(-1.3, 1.3); 
        
        str1 = path + outputFolders[5] + delRhoOverRhoRefUSMinusLSLabel1 + binLabelCent[i] + fileType;
        fullySubtractedCorrCent[i]->Draw("SURF1");
        c->SaveAs(str1);
        
        str1 = phiProj + delRhoOverRhoRefUSMinusLSLabel1 + binLabelCent[i];         //fully subtracted phi proj
        fullySubtractedCorrCentPhiProj[i] = new TH1D(str1, str1, NUM_PHI_BINS, -TMath::PiOver2(), 3*TMath::PiOver2());  
        fullySubtractedCorrCentPhiProj[i] = (TH1D*)fullySubtractedCorrCent[i]->ProjectionY();  
        str1 = path + outputFolders[5] + phiProj + delRhoOverRhoRefUSMinusLSLabel1 + binLabelCent[i] + fileType;        
        fullySubtractedCorrCentPhiProj[i]->Draw();
        c->SaveAs(str1);
        
    } //end delRho_over_rho_US minus delRho_over_rho_LS   */
        
        
    /*for(int i = 8; i < 11; i++){ //begin US sibling minus LS sibling
   
        str1 = USMinusLSSibLabel1 + binLabelCent[i];
        USSibMinusLSSib[i] = new TH2D(str1, str1, NUM_ETA_BINS, -2, 2, NUM_PHI_BINS, -TMath::PiOver2(), 3*TMath::PiOver2());
        
        sibCorrLSBin[i]->Scale(LSScaleFactor);                 //very crude LS scaling
        
        USSibMinusLSSib[i]->Add(sibCorrUSBin[i], sibCorrLSBin[i], 1, -1);
        
        formatCorrHist(USSibMinusLSSib[i]); //formatting
        
        
        USSibMinusLSSib[i]->GetXaxis()->SetRangeUser(-1.6, 1.6); 
        
        
        
        str1 = path + outputFolders[6] + USMinusLSSibLabel1 + binLabelCent[i] + fileType;
        USSibMinusLSSib[i]->Draw("SURF1");
        c->SaveAs(str1);
        
        str1 = phiProj + USMinusLSSibLabel1 + binLabelCent[i];         //fully subtracted phi proj
        USSibMinusLSSibPhiProj[i] = new TH1D(str1, str1, NUM_PHI_BINS, -TMath::PiOver2(), 3*TMath::PiOver2());  
        USSibMinusLSSibPhiProj[i] = (TH1D*)USSibMinusLSSib[i]->ProjectionY();  
        str1 = path + outputFolders[6] + phiProj + USMinusLSSibLabel1 + binLabelCent[i] + fileType;        
        USSibMinusLSSibPhiProj[i]->Draw();
        c->SaveAs(str1);
        
    } //end US sibling minus LS sibling     */
  
    //TH2D* USMixMinusLSMix[11];
    //TH2D* SibUSMinusLSOverSubtractedRef[11];
  
    /*for(int i = 8; i < 11; i++){ //begin US mix minus LS mix 
   
        str1 = USMinusLSMixLabel1 + binLabelCent[i];
        USMixMinusLSMix[i] = new TH2D(str1, str1, NUM_ETA_BINS, -2, 2, NUM_PHI_BINS, -TMath::PiOver2(), 3*TMath::PiOver2());
        
        mixCorrLSBin[i]->Scale(LSScaleFactor);                 //very crude LS scaling
        
        USMixMinusLSMix[i]->Add(mixCorrUSBin[i], mixCorrLSBin[i], 1, -1);
        
        formatCorrHist(USMixMinusLSMix[i]); //formatting
        
        USMixMinusLSMix[i]->GetXaxis()->SetRangeUser(-1.6, 1.6); 
        
        str1 = path + outputFolders[7] + USMinusLSMixLabel1 + binLabelCent[i] + fileType;
        USMixMinusLSMix[i]->Draw("SURF1");
        c->SaveAs(str1);
        
        str1 = phiProj + USMinusLSMixLabel1 + binLabelCent[i];         //fully subtracted phi proj
        USMixMinusLSMixPhiProj[i] = new TH1D(str1, str1, NUM_PHI_BINS, -TMath::PiOver2(), 3*TMath::PiOver2());  
        USMixMinusLSMixPhiProj[i] = (TH1D*)USMixMinusLSMix[i]->ProjectionY();  
        str1 = path + outputFolders[7] + phiProj + USMinusLSMixLabel1 + binLabelCent[i] + fileType;        
        USMixMinusLSMixPhiProj[i]->Draw();
        c->SaveAs(str1);
        
    } //end US mix minus LS mix */
 
     //TH2D* USMixMinusLSMixScaled[11];
 
   /* for(int i = 8; i < 11; i++){ //begin scaled US mix minus LS mix
   
        str1 = USMinusLSMixScaledLabel1 + binLabelCent[i];
        USMixMinusLSMixScaled[i] = (TH2D*) USMixMinusLSMix[i]->Clone();
        
        numSib = USSibMinusLSSib[i]->Integral(1, NUM_ETA_BINS, 1, NUM_PHI_BINS);
        numMix = USMixMinusLSMix[i]->Integral(1, NUM_ETA_BINS, 1, NUM_PHI_BINS);
        
        USMixMinusLSMixScaled[i]->Scale(numSib/numMix);
        
        formatCorrHist(USMixMinusLSMixScaled[i]); //formatting
        
        USMixMinusLSMixScaled[i]->GetXaxis()->SetRangeUser(-1.6, 1.6); 
        
        
        
        str1 = path + outputFolders[8] + USMinusLSMixScaledLabel1 + binLabelCent[i] + fileType;
        USMixMinusLSMixScaled[i]->Draw("SURF1");
        c->SaveAs(str1);
        
        str1 = phiProj + USMinusLSMixScaledLabel1 + binLabelCent[i];         //fully subtracted phi proj
        USMixMinusLSMixScaledPhiProj[i] = new TH1D(str1, str1, NUM_PHI_BINS, -TMath::PiOver2(), 3*TMath::PiOver2());  
        USMixMinusLSMixScaledPhiProj[i] = (TH1D*)USMixMinusLSMixScaled[i]->ProjectionY();  
        str1 = path + outputFolders[8] + phiProj + USMinusLSMixScaledLabel1 + binLabelCent[i] + fileType;        
        USMixMinusLSMixScaledPhiProj[i]->Draw();
        c->SaveAs(str1);
        
    } *///end scaled US mix minus LS mix
 
 
    /*for(int i = 8; i < 11; i++){ //begin US sibling minus LS sibling over subtracted mix
   
        str1 = USMinusLSSubtractedLabel1 + binLabelCent[i];
        SibUSMinusLSOverSubtractedRef[i] = new TH2D(str1, str1, NUM_ETA_BINS, -2, 2, NUM_PHI_BINS, -TMath::PiOver2(), 3*TMath::PiOver2());
        
        SibUSMinusLSOverSubtractedRef[i]->Add(USSibMinusLSSib[i], USMixMinusLSMixScaled[i], 1, -1);
        SibUSMinusLSOverSubtractedRef[i]->Divide(USMixMinusLSMixScaled[i]);
        
        formatCorrHist(SibUSMinusLSOverSubtractedRef[i]); //formatting
        
        SibUSMinusLSOverSubtractedRef[i]->GetXaxis()->SetRangeUser(-1.6, 1.6); 
        
        str1 = path + outputFolders[9] + USMinusLSSubtractedLabel1 + binLabelCent[i] + fileType;
        SibUSMinusLSOverSubtractedRef[i]->Draw("SURF1");
        c->SaveAs(str1);
        
        /*str1 = phiProj + USMinusLSSubtractedLabel1 + binLabelCent[i];         //fully subtracted phi proj
        USMixMinusLSMixScaledPhiProj[i] = new TH1D(str1, str1, NUM_PHI_BINS, -TMath::PiOver2(), 3*TMath::PiOver2());  
        USMixMinusLSMixScaledPhiProj[i] = (TH1D*)SibUSMinusLSOverSubtractedRef[i]->ProjectionY();  
        str1 = path + outputFolders[8] + phiProj + USMinusLSSubtractedLabel1 + binLabelCent[i] + fileType;        
        USMixMinusLSMixScaledPhiProj[i]->Draw();
        c->SaveAs(str1);
        
    } //end US sibling minus LS sibling over subtracted mix*/